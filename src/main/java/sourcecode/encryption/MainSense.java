package sourcecode.encryption;


/**
 * @name
 * @ClassName MainSense
 * @Description 常用的加密算法总结以及测试
 * @author: zdw
 * @date 2019/3/1 10:11
 * 加密为了隐私性，可以解密，签名是为了验证身份，不能逆向解密
 * 1.常见加密算法  ①单项加密：MD5，SHA ，BASE64（编码）②对称加密 DES算法 AES算法 ③ 非对称加密
 * 其实加密算法都是不分语言的，常见的加密算法分为单向加密和非对称加密：
 * <p>
 * 1.1 单向加密：
 * 主要用来作为签名，也可以称为签名算法，验证数据传输的过程中，是否被篡改过。无法从加密后的签名解密出原始数据，加密者自己不能。
 * 例：客户端向服务器传输一个字符串str以及其单向加密后的签名sign，服务器接收到后，对字符串str进行同样的单向加密得到签名sign2，如果sign等于sign2，就可以认为字符串str没有被篡改过。
 * <p>
 * BASE64 严格地说，属于编码格式，而非加密算法
 * MD5(Message Digest algorithm 5，信息摘要算法)
 * SHA(Secure Hash Algorithm，安全散列算法)
 * HMAC(Hash Message Authentication Code，散列消息鉴别码
 * 1.2 非对称加密：
 * 采用公钥和私钥的形式，将数据加密后再传输。公钥给客户端，私钥保存在服务器。公钥和私钥是一一成对的关系。公钥加密—–>私钥解密，私钥加密—->公钥解密。
 * <p>
 * DES(Data Encryption Standard，数据加密算法)
 * PBE(Password-based encryption，基于密码验证)
 * RSA(算法的名字以发明者的名字命名：Ron Rivest, AdiShamir 和Leonard Adleman)
 * DH(Diffie-Hellman算法，密钥一致协议)
 * DSA(Digital Signature Algorithm，数字签名)
 * ECC(Elliptic Curves Cryptography，椭圆曲线密码编码学)
 * 2.单向加密（签名）算法中的加盐
 * 涉及身份验证的系统都需要存储用户的认证信息，常用的用户认证方式主要为用户名和密码的方式，为了安全起见，用户输入的密码需要保存为密文形式，可采用已公开的不可逆的hash加密算法，比如SHA256, SHA512, SHA3等，对于同一密码，同一加密算法会产生相同的hash值，这样，当用户进行身份验证时，也可对用户输入的明文密码应用相同的hash加密算法，得出一个hash值，然后使用该hash值和之前存储好的密文值进行对照，如果两个值相同，则密码认证成功，否则密码认证失败。
 * <p>
 * 由于密码是由用户设定的，在实际应用中，用户设置的密码复杂度可能不够高，同时不同的用户极有可能会使用相同的密码，那么这些用户对应的密文也会相同，这样，当存储用户密码的数据库泄露后，攻击者会很容易便能找到相同密码的用户，从而也降低了破解密码的难度，因此，在对用户密码进行加密时，需要考虑对密码进行掩饰，即使是相同的密码，也应该要保存为不同的密文，即使用户输入的是弱密码，也需要考虑进行增强，从而增加密码被攻破的难度，而使用带盐的加密hash值便能满足该需求。
 * <p>
 * 加盐的实现方法：
 * 1. 加密存储
 * 输入： 密码字符串passWord
 * <p>
 * 输出：盐值 salt 、密码密文passWordHash
 * <p>
 * 函数：加密hash函数
 * <p>
 * 其中：“盐值 salt”是在加密过程中生成的随机字符串；
 * <p>
 * 可以将salt放到passWord前面作为前缀或放到passWord后面作为后缀得到新的字符串PS，即，PS = password和salt的组合串;
 * <p>
 * 密码密文passWordHash = Hash加密函数(PS );
 * <p>
 * 将用户名、密码密文passWordHash和盐值salt一起保存到数据库中。
 * <p>
 * 2. 密码校验
 * 输入： 密码字符串passWordCur
 * <p>
 * 输出：密码校验是否成功
 * <p>
 * 处理：
 * 1)、取出当前用户密码加密时使用的盐值salt
 * <p>
 * 2)、得到本次输入的密码passWordCur和盐值salt的组合字符串PS
 * <p>
 * 3)、得出本次输入密码的密文passWordHashCur= Hash加密函数(PS );
 * <p>
 * 4)、比较passWordHashCur和用户最初设置的密码密文passWordHash是否一致，如果一致，则校验成功，否则校验失败
 */
public class MainSense {
    private static MainSense instance = new MainSense();

    public static void main(String[] args) {
        instance.daxiangjiami();
    }

    /**
     * 单向加密:base64,MD5
     * 即加密之后不能解密，一般用于数据验证
     * Message Digest algorithm 5，信息摘要算法，MD5
     * - 一般用于确保信息的传输完整一致性，校验传输的数据是否被修改，一旦原始信息被修改，
     * 生成的 MD5 值将会变得很不同，还可以加盐salt(随机生成),用于密码保存.
     * 场景:1.签名，防止参数被修改 2.密码保存
     */
    private void daxiangjiami() {
    }

    /**
     * 对称加密
     * 对称加密的意思就是信息收发都有相同的一把钥匙，消息的加密解密都用这进行
     */
    private void duichengjiami() {

    }

    /**
     * 1.3 非对称加密  RSA:可以用于加密，也可以用于签名。签名不可以，是先进行hash运算，然后在加密
     * 非对称加密算法是一种密钥的保密方法。 非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；
     * 如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。
     * <p>
     * 比如支付宝支付，商家用商家密钥对订单信息进行加密生成签名，然后支付宝用商家公钥对订单验签，
     * ，支付宝把返回结果用支付宝公钥进行加密，商家收到支付结果后用支付宝公钥进行解密
     * <p>
     * <p>
     * 这里一共有两组四个密钥：A的公钥（PUB_A），A的私钥（PRI_A）；B的公钥（PUB_B），B的私钥（PRI_B）。
     * 公钥一般用来加密，私钥用来签名。通常公钥是公开出去的，但是私钥只能自己私密持有。
     * 公钥和私钥唯一对应，用某个公钥签名过得内容只能用对应的私钥才能解签验证；
     * 同样用某个私钥加密的内容只能用对应的公钥才能解密。
     * 这时A向B发送信息的整个签名和加密的过程如下：
     * 1、A先用自己的私钥（PRI_A）对信息（一般是信息的摘要）进行签名。
     * 2、A接着使用B的公钥（PUB_B）对信息内容和签名信息进行加密。
     * 这样当B接收到A的信息后，获取信息内容的步骤如下：
     * 1、用自己的私钥（PRI_B）解密A用B的公钥（PUB_B）加密的内容；
     * 2、得到解密后的明文后用A的公钥（PUB_A）解签A用A自己的私钥（PRI_A）的签名。
     * 从而整个过程就保证了开始说的端到端的唯一确认。
     * A的签名只有A的公钥才能解签，这样B就能确认这个信息是A发来的；
     * A的加密只有B的私钥才能解密，这样A就能确认这份信息只能被B读取。
     */
    private void feiduichengjiami() {

    }
}
